#!/bin/sh

tests=("2\n1, 0, 5\n2, 0, 3"
       "3\n1, 0, 2\n2, 3, 2\n3, 6, 4"
       "4\n1, 3, 3\n2, 2, 3\n3, 1, 3\n4, 0, 3"
       "4\n1, 0, 7\n2, 0, 4\n3, 0, 1\n4, 0, 4")

RED='\033[0;31m'
NC='\033[0m'

result_path="results"

clear

while [[ true ]]
do
    read -p "specify quanta (inclusive) [0-9]+ (if none specified, default is 8): " quanta

    if ! [[ "$quanta" =~ ^[0-9]+$ ]]
    then
	if [[ -z "$quanta" ]]
	then
	    quanta=8
	    break
	else	
	    echo "[invalid quanta]"
	fi
    else
	break
    fi
done

if test -f $result_path.log
then
    while true
    do
	read -p "$(echo -e "${RED}$result_path.log exists. do you want to remove [N/y] ${NC}")" yn

	case $yn in
	    [yY] )
		clear
		echo "[removing $result_path.log...]"
		break;;
	    [nN] )
		clear
		echo "[creating a new file...]"
		break;;
	    * )
		clear
		echo "[creating a new file...]"
		yn="n"
		break;;
	esac
    done
	    
    if [ "$yn" = "n" ] || [ "$yn" = "N" ]
    then
	fileno=1
	while test -f $result_path.log
	do
	    result_path="results-$fileno"
	    fileno=$((fileno + 1))
	done
    else
	rm $result_path.log
    fi
else
    clear
fi


result_path="$result_path.log"

echo "[creating $result_path...]"
touch $result_path

echo "[testing with quantum up to (inclusive) $quanta]" | tee -a $result_path
echo "[calling make clean...]"
make clean

echo

echo "[calling make...]"
make

echo



echo "[creating case.txt...]"
touch case.txt

for i in ${!tests[@]}
do
    echo "[loading test case $((i + 1)) into case.txt...]"
    echo -e "${tests[$i]}" > case.txt

    echo "[testing case $((i + 1))]" | tee -a $result_path
    cat case.txt | tee -a $result_path

    j=1
    while [[ $j -ne $((quanta + 1)) ]]
    do
	echo "[quantum: $j]" | tee -a $result_path
	./rr case.txt $j | tee -a $result_path
	echo | tee -a $result_path
	j=$((j + 1))
    done


    echo
done

echo "[removing case.txt...]"
rm case.txt


echo "[calling make clean...]"
make clean

echo
echo "[results are written to $result_path]"
echo "[exiting...]"
