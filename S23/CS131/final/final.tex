\documentclass{article}
\usepackage{amsmath, amsthm, amssymb, graphicx, enumitem, esvect}


% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[arrow]{xy}

\title{CS 131}
\date{}

\begin{document}
\maketitle

\tableofcontents

\newpage
\section{Garbage Collection}
Garbage collection or automatic memory management ensures the
following:
\begin{enumerate}[label=(\roman*)]
\item Eliminate Memory Leaks: Ensures all allocated memory is properly
  deallocated/freed.
\item Eliminates Dangling Pointers and Use of Dead Objects: Prevents
  access to deallocated/freed objects.
\item Eliminates Double-free Bugs: Prevents the need to manually
  de/allocate memory (for the most part).
\item Eliminates Manual Memory Management: See (iii).
\end{enumerate}
Note that bulk garbage collection occurs when free memory runs low
(on-demand). The program will freeze execution when GC is taking place.


\subsection{Mark and Sweep}
Mark and Sweep traverses through the program, marking all active
objects. Once a full traversal is complete, any unmarked objects are
deallocated/freed. The two phases are as follows:
\begin{enumerate}[label=(\roman*)]
\item Mark: The garbage collector starts from the global scope (out $\to$ in) and
recursively traverses the object graph, marking all reachable
objects.
\item The garbage collector scans the entire memory, deallocating objects
that were not marked in the Mark phase of the algorithm.
\end{enumerate}



\subsubsection{Issues: Memory Fragmentation}
One of the consequences of Mark and Sweep is potential Memory
Fragmentation. The heap now has random-sized blocks of free memory
interlaced with in-use memory. This is not ideal since finding free
blocks of appropriately sized memory becomes difficult. 

\subsection{Mark and Compact}
Mark and Compact is an alternative to Mark and Sweep: Instead of
deallocating memory in place, all active objects are moved to a new
block of memory. The old block of memory is then deallocated. This
prevents Memory Fragmentation$^{1.1.1}$ as all of the active objects
are stored in a contiguous block.

\subsection{Reference Counting}
Each object has a count of the number of active references that point
at it. When the count reaches 0, the object is deallocated and all
references that the object used to point to are subsequently
reevaluated.

\subsubsection{Issues: Cascading Objects}
Removing references as they are deleted may lead to slow programs as
the (now deleted) reference may lead to a cascade of objects being
deallocated at once. Thus, a common way to improve efficiency is to
store objects that need to be deallocated into a list, then
deallocating at regular intervals throughout the program execution.

\subsubsection{Issues: Circular References}
Reference counting cannot handle circular references, as each object
in the circular reference will always maintain a count of \textit{at
  least} 1. Thus, circularly referenced objects may never be deleted.

\subsection{Corollary: Garbage Collection Unpredictability}
It is impossible to predict when/if a given object will be deallocated
via garbage collection because garbage collection only occurs when
there is memory pressure. One consequence of this is that anything an
object allocates that is usually deallocated by a destructor
(e.g. temp files) should be properly dealt with manually, since there
is no guarantee that the destructor/finalizer will ever run since the
object may never be garbage collected. (e.g. Given a program that
creates (sufficiently many) temp files, there may be enough RAM such
that there is never any memory pressure. Then, hard drive space may
run out before RAM does.) 


\section{Memory Safety (Object Lifetime)}
Objects may hold resources (e.g. dynamic objects, temp files) that
need to be deallocated/destroyed concurrently with the deallocation of
the object itself. There are three main ways this is handled:
\begin{enumerate}[label=(\roman*)]
\item (Non-GC\footnote{GC: Garbage Collected}): Destructors:
  Destructors are automatically called when objects are deallocated,
  and is guaranteed to run immediately when it is called.
\item (GC): Finalizers: A finalizer method is called by a garbage
  collector before deallocating the object itself. Finalizers are
  \textbf{not} guaranteed to run and therefore should be called
  explicitly when necessary.
\item (GC) Manual Destruction: A disposal function (defined
  suggestively) should be defined and called when necessary, forcing
  the destruction of resources.
\end{enumerate}

\subsection{Destructors}
Destructors are only used in languages without garbage
collection. They are implicitly called at the end of an object's
lifetime and are used to deallocate not only the object itself, but any side
effects (e.g. other (dynamic) objects, closign network connections,
temp files) that the object may have created as well.

\subsection{Finalizers}
Finalizers are similar to destructors, but with the caveat that they
may never be called. They serve the same purpose as a destructor, but
since Finalizers are used in garbage-collected languages, they should
be called explicitly called (when necessary) whenever they are
implemented.

\subsection{Manual Destruction}
Manual distruction methods are user-defined functions (often named
suggestively (e.g. \texttt{dispose()})) that implement the
deallocation of any side effects. These functions must be explicitly
called (when necessary) in order to have any effect.











\section{Parameter Passing}
\subsection{Semantics}
\begin{enumerate}[label=(\roman*)]
\item Pass by Value: A copy of the argument's value/object gets passed
  in to the formal parameter.
\item Pass by Reference: The formal parameter is an alias for the
  argument's value/object.
\item Pass by Object Reference: A pointer to the argument's
  value/object gets passed in to the formal parameter.
\item Pass by Name/Need: The parameter points to an expression graph
  that represents the argument.
\end{enumerate}

\subsubsection{Examples}
\subsubsection*{Pass by Value}
\begin{verbatim}
void add_to_string(std::string n) {
    std::string t = n + " add";
    n = t;
}

int main() {
    std::string s = "String";
    add_to_string(s);
    std::cout << s;
}
\end{verbatim}
prints out: \texttt{String}

\subsubsection*{Pass by Reference}
\begin{verbatim}
void add_to_string(std::string& n) { ... }
void main() { see example above }
\end{verbatim}
prints out: \texttt{String add}

\subsubsection*{Pass by Object Reference}
\begin{verbatim}
class Nerd:
    def __init__(self, name, iq):
        self.name = name
        self.iq = iq

    def study(self):
        self.iq = self.iq + 50
...

def increase_iq(n):
    n.study()

def main():
    a = Nerd("name", 100)
    increase_iq(a)
    print(a.iq())
\end{verbatim}
prints out: \texttt{150}






\subsection{Positional/Named/Optional Parameters}
\begin{enumerate}[label=(\roman*)]
\item Positional Parameters: Arguments must match the order of the
  formal parameters.
\item Named Parameters: The name of the parameter must be explicitly
  defined in the function call (e.g. \texttt{your\_function(arg =
    10)}). The arguments need not be in the same order as the formal parameters.
\item Optional Parameters: Default values can be set to formal
  parameters (e.g. \texttt{your\_function(one, two = 10)}. Here,
  \texttt{two} has a default value of 10, so calling
  \texttt{your\_function(20)} will assign the formal parameters: \texttt{one = 20, two = 10}).
\end{enumerate}

\subsection{Variadic Functions}
A function that can take in a variable number of arguments
(e.g. Python's \texttt{print()}). \\
Most languages gather variadic arguments and add them to a container
(e.g. array, dictionary, tuple, etc.) and pass the container into the
function for processing.






\section{Returning Results/Error Handling}
\subsection{Bugs/Errors/Results}
\begin{enumerate}[label=(\roman*)]
\item Bugs: A logic flaw. \\
  e.g. out of bounds access, dereferencing a nullptr, divide by zero,
  illegal cast, unmet pre/postconditions/invalid object state. 
\item Unrecoverable Errors: Non-bug errors where the only option is to
  abort the program. \\
  e.g. out of memory error, network host not found, disk is full
  error, invalid app configuration. 
\item Recoverable Errors: Non-bug errors where recovery is possible
  and the program can continue executing. \\
  e.g. file not found, network service temporarily overloaded,
  malformed email address.
\item Results: Operation status. \\
  e.g. return value of \texttt{container.find(key)} (\texttt{null,
    value}), password correctness.
\end{enumerate}

\subsection{Error Handling Techniques}
\begin{enumerate}[label=(\roman*)]
\item Come up with your own: Create your own error handling system. \\
  e.g. Defining enumerated types for return status.
\item Error Objects\footnote{Related to:
    \textit{\textbf{Recoverable Errors, Results}}.}: language-specific
  objects used to return an explicit error result from a function to its
  caller regardless of return value. They are returned along the
  function's result as a separate return value. 
\item Optional Objects$^1$: Return a single
  result that can be either a valid value or a generic failure
  condition. Most often represented as a \texttt{struct} that holds a
  \texttt{value} and a \texttt{bool}, indicating whether or not the
  \texttt{value} is valid. Used only if there's an \textbf{obvious, single
  failure mode}.
\item Result Objects$^1$: Return a single result that can be either a
  valid value or a specified Error Object.
\item Assertions/Conditions\footnote{Related to: \textit{\textbf{Bugs,
        Unrecoverable Errors}}}: Checks a condition, aborting if not met.
\item Exceptions/Panics: Exceptions are thrown up the calling
  hierarchy and are either caught and handled or the program terminates.
\end{enumerate}

\subsubsection*{Example: Error Objects}
\begin{verbatim}
func area(rad float32) (float32, error) {
    if rad >= 0
        return math.Pi * rad * rad, nil
    else
        return 0, errors.New("negative radius")
}

func cost(rad float32, cost float32) (float32, error) {
    area, err := area(rad)
    if err != nil
        return 0, err
    return cost * area, nil
}
\end{verbatim}

\subsubsection*{Example: Optionals}
\begin{verbatim}
func divide(a: Float, b: Float) -> Float? {
    if b == 0
        return nil;
    return a / b;
}

var opt: Float?;
opt = divide(a: 10, b: 20);

if opt != nil
    let c: Float = opt!;
else
    print("error");
\end{verbatim}

\subsubsection*{Example: Results}
\begin{verbatim}
enum ArithmeticError: Error {
    case divideByZero
    ...
}

func divide(x: Double, y: Double) -> Result<Double, ArithmeticError> {
    if y == 0
        return .failure(.divideByZero)
    else
        return .success(x / y)

let result = divide(x: 10, y: 0)
switch result {
    case .success(let number):
        print(number)
    case .failure(let error):
        handleError(error)
\end{verbatim}

\subsubsection*{Assertions: Pre/Post Conditions, Invariants}
\begin{enumerate}[label=(\roman*)]
\item Precondition: Something that must be true at the start of a
  function for it to work correctly.
\item Postcondition: Something that the function guarantees is true
  once it finishes.
\item Invariants: Condition(s) that are expected to be true across a
  function or class's execution.
\end{enumerate}

\subsection{Exception Handling}
Exsception handling\footnote{Related to \textit{\textbf{Bugs,
      Unrecoverable/Recoverable Errors}}.} handles exceptional
situations/unexpected errors independently of the main logic.
\subsubsection{Throw and Catch}
A thrower will throw an exception object to the calling function if an operation
results in an error. A catcher will try a block of code, catching any
errors that the function returns, handling it in the catch block.
\subsubsection*{Example}
\begin{verbatim}
void f() {
    try {
        g();
        h();
    }
    catch (Exception& e) {
        handle(e);
    }

void g() { ... }
void h() {
    ...
    throw runtime_error("...");
    ...
}
\end{verbatim}
Exceptions will propagate up until someone catches it. If no one
catches the exception, the program will terminate.
\subsubsection{Finally} The finally block will always execute after a
try/catch block \textbf{no matter what}.
\subsubsection{Exception Handling Guarantees} When writing exceptions,
ensure that at least one of the following is met:
\begin{enumerate}[label=(\roman*)]
\item No-throw/Failure Transparency: A function guarantees it won't
  throw an exception. If an exception occurs within the function, it
  will handle it internally.
\item Strong Exception: If a function throws an exception, the
  program's state will be rolled back to before the function call.
\item Basic Exception: If a function throws an exception, it leaves
  the program in a valid state (no resources are leaked, all
  invariants are in tact).
\end{enumerate}

\subsection{Panics}
Panics\footnote{Related to \textit{\textbf{Bugs, Unrecoverable
      Errors}}.} are used to abort execution. They are like exceptions
that are never caught.





\section{n-class Functions}
\begin{enumerate}[label=(\roman*)]
\item First-class: Functions are treated as data.
\item Second-class: Functions can be passed as arguments but not
  returned/assigned to variables.
\item Third-class: Functions can only be called.
\end{enumerate}

\subsection{Anonymous (Lambda) Functions}
Lambdas are smaller functions without a name and can be implemented in
multiple ways: pure or not pure.





\section{Polymorphism}
\subsection{Statically Typed Polymorphism}
\begin{enumerate}[label=(\roman*)]
\item Ad-hoc: Define specialized version of the same function for each
  type (overloading).
\item Parametric: Define a single version of a function/class that can
  operate on many, potentially unrelated, types
  (e.g. templates/generics)\footnote{Parametric polymorphism in
    dynamically typed languages are implemented via duck typing.}.
\item Subtype: A function is designed to operate on objects of a base
  class and all of its subclass/derived classes.
\end{enumerate}

\subsubsection*{Example: Ad-hoc Polymorphism}
\begin{verbatim}
bool greater(Dog a, Dog b) {
    return a.bark() > b.bark();
}
bool greater(Student a, Student b) {
    return a.GPA() > b.GPA();
}

int main() {
    Dog spot, penny;
    if(greater(spot, penny))
        std::cout << "spot wins" << std::endl;

    Dog carey, david;
    if(greater(carey, david))
        std::cout << "carey wins" << std::endl;
}
\end{verbatim}

\subsubsection{Parametric Polymorphism: Templates}
The compiler will generate a concrete version of the templated
function/class by substituting the type parameter. Templates are
type-safe, as the compiler generates a concrete version, so it will
also type-check. Templates have the same runtime efficiency since they
are compiled into concrete versions beforehand.

\subsubsection{Parametric Polymorphism: Generics}
Each generic function/class is compiled on its own, independent of any
code that might use it later. Because of this, generics don't make any
assumptions about types. The compiler will ensure the code uses the
generic's interfaces correctly on a case by case basis. Bounding is a
process where we place restrictions on what types can be used with the
generic. Generics are type-safe since the compiler will verify that
the type is compatible with the generic. In unbounded generics, you
can only call methods that are common among all objects.

\subsubsection{Specialization}
Specialization is when a dedicated version of a function/class is
defined for a specific type. This dedicated version is used instead of
the generic/templated version for that type. This handles special
cases and/or improves efficiency.



\subsection{Subtype Polymorphism}
Subtype polymorphism is the ability to substitute an object of a
subtype anywhere a supertype is expected (e.g. \texttt{Circle} $\to$
\texttt{Shape}). All sub/super typing rules apply to sub/super
classes. Subtyping is implemented in statically typed
languages. Dynamically typed languages use duck typing to achieve the
same semantics.


\section{Corollary: Static Dispatch}
Static dispatch is when the correct function implementation can be
determined at compile time.

\section{Corollary: Dynamic Dispatch}
Dynamic dispatch is the process that determines which function
implementation to invoke when a function is called. It is determined
at runtime (even for statically typed languages) either:
\begin{enumerate}[label=(\roman*)]
\item Based on the target's object class.
\item By seeing if the target object has a matching method (regardless
  of object type).
\end{enumerate}

\subsubsection{Implementation: vtable}
One implementation of dynamic dispatch is by using a vtable. A vtable
is associated with the object's type and contains a table of function
implementations for an object. When a function is called, the vtable
will check for a matching function, invoking the one it points to.

\subsection{Dynamic Dispatch in Statically Typed Languages}
In statically typed languages, the language examines the class of an
object at the time of the method call to determine which function to
invoke.

\subsection{Dynamic Dispatch in Dynamically Typed Languages}
Because a programmer can add/remove methods at runtime, we cannot rely
on an object's class definition to determine which function to
call. Rather, a unique vtable is stored for individual objects.


\section{Object Oriented Programming}
\begin{enumerate}[label=(\roman*)]
\item Encapsulation: Bundling of a public interface and private dat
  fields/code together into a cohesive unit.
\item Classes: Blueprint for creating objects - defines a public
  interface, code for methods, and dat fields.
\item Interfaces: A related group of function prototypes that we want
  one+ classes to implement.
\item Objects: Represents a "thing" - each object has its own
  interface, code, and field values.
\item Inheritance: A derived class inherits either the code,
  interface, or both, from a base class. Derived classes can override
  the base class's code or add to its interface.
\item Subtype Polymorphism: Code designed to operate on an object of
  type T or any of T's subclasses.
\item Dynamic Dispatch: The actual code that runs when a method is
  called depends on the target object, with is determined at runtime.
\end{enumerate}

\subsection{Encapsulation}
\begin{enumerate}[label=(\roman*)]
\item Bundle related public interface, data, and code together into a
  cohesive, single class/object.
\item Hide data/implementation details of a class/object from its clients,
  forcing them to use the public interface.
\end{enumerate}
Some benefits include:
\begin{enumerate}[label=(\roman*)]
\item Simpler programs: Prevents deep coupling between components,
  making code less complex/buggy.
\item Easier improvements: Improve implements without impacting other
  components. 
\item Better modularity: Easier code reuse.
\end{enumerate}
Best practices include:
\begin{enumerate}[label=(\roman*)]
\item Hide all implementation details from other classes.
\item Make all member fields, constants, helper methods \texttt{private}.
\item Reduce coupling with other classes.
\item Make sure constructors \textbf{completely} initialize objects so
  users don't have to call extraneous methods to complete initialization.
\end{enumerate}

\subsection{Classes}
A class is a blueprint that specifies data fields and methods that can
be used to create objects. A class has:
\begin{enumerate}[label=(\roman*)]
\item Name
\item Public interface
\item Fields (attributes, instance variables)
\item Private methods
\item Method implementations
\item Constructor/Destructor (Finalizer)
\end{enumerate}
\textit{\textbf{Note:}} A class definition implicitly defines a type: When you
define a new class, it automatically creates a new type of the same
name. A class name and a class type are \textbf{not} the same.

\subsubsection{Class Fields/Methods}
Class fields, also known as singletons, are fields that are shared
among all objects, and is "static" throughout the program's
lifetime. Some uses include:
\begin{enumerate}[label=(\roman*)]
\item Defining class-level constants.
\item Counting the number of objects created.
\item Assigning each object a unique ID.
\end{enumerate}
Similarly to class fields, class methods are also methods that are
shared among all classes, and thus can only access class-level
variables (such as singletons). Note that we can only call these
methods via the class, and not a particular instance of a class
(e.g. \texttt{Foo.static\_method()} rather than
\texttt{o.static\_method()} where \texttt{Foo o = new Foo()}). Some
uses of class level methods include:
\begin{enumerate}[label=(\roman*)]
\item A method that only needs to access class-level variables
  (singletons).
\item Defining utility functions (e.g. a \texttt{Math} library)
\end{enumerate}

\subsubsection{This/Self}
\texttt{this} and \texttt{self} are both keywords used to reference
the current object. The implementation is as follows: Given the
following class,
\begin{verbatim}
class Nerd {
private:
    std::string name;
    int IQ;
public:
    Nerd(const string& name) {
        this-> name = name;
        IQ          = 100 // this->IQ is optional
    }

    std::string talk() { return this-> name + " likes PI."; }
};
...
Nerd n("Carey");
std::cout << n.talk();
\end{verbatim}
OOP languages like C++ and Java pass in a pointer/object reference as
an implicit first parameter in each instance method\footnote{Class methods don't have a \texttt{this/self}
parameter since they don't operate on a specified instance.}:
\begin{verbatim}
class Nerd {
private:
    std::string name;
    int IQ;
public:
    Nerd(Nerd* this, const string& name) {
        this-> name = name;
        this->IQ    = 100 // this->IQ is optional
    }

    std::string talk(Nerd* this) { return this-> name + " likes PI."; }
};
...
Nerd n;
init(&n, "Carey");
std::cout << talk(&n);
\end{verbatim}
\textit{\textbf{Note:}} Languages like Python\footnote{In Python, the
  \texttt{self} is \textbf{not} optional since Python never explicitly defines
  member variables (instead, using \texttt{self.variable} to create
  new ones. Therefore, removing \texttt{self} introduces ambiguitiy as
  to which scope a variable is in.} and Go explicitly pass
\texttt{this/self} in as the first parameter.

\subsubsection{Access Modifiers}
Access modifiers are keywords/syntax to specifiy
visibility/accessibility of class methods/fields to code outside of
the class. The levels of access are as follows:
\begin{enumerate}[label=(\roman*)]
\item Public: Any part of the program can access to the method(s)/field(s).
\item Protected: Only subclasses have access to the method(s)/field(s).
\item Private: Only the class itself can access to the method(s)/field(s)
\end{enumerate}
\textit{\textbf{Note:}} Different languages have different visibility
defaults.

\subsubsection{Accessors/Mutators}
Accessors/Mutators allow users to change private class attributes
outside of the class itself. An accessor's/getter's sole purpose is to retrieve
a certain attribute and is expected to be \texttt{const}. A
mutator's/setter's sole purpose is to mutate a class variable. This
allows for easier refactoring and code stability.

\subsubsection*{Corollary: Properties}
Properties are languaged-provided getters/setters and allow an outside
class to refer to the variable as if it were public, but the language
will implicitly call the getter/setter. Properties are used to expose
the \textbf{state} of a class. Traditional methods are used when
exposing behavior of a class or exposing a state that requires
\textbf{heavy} computation. Properties may be considered bad OOP style
since the whole point of getters/setters is to hide implementation, so
"exposing" private members by allowing outside classes to directly
reference them (though not \textit{actually} referencing them) can be confusing.


\subsection{Interfaces}
An interface is a related group of function prototypes that describes
behaviors we want a group of classes to implement. They are meant for
classes that are loosely related only via common functions.

\subsubsection*{Example}
A \texttt{Circle}, \texttt{Square}, and \texttt{Rectangle} all have
different ways of computing \texttt{area}, but they share the common
functionality of being able to compute \texttt{area}. Thus, a
\texttt{Shape} interface can be provided:
\begin{verbatim}
interface Shape {
    public double area();
}

class Square implements Shape {
    public double area() { return w * w } // where w is a private field
}

class Rectangle implements Shape {
    public double area() { return l * w } // where l, w are private fields
}
\end{verbatim}
This way, we can still refer to both \texttt{Square} and
\texttt{Rectangle} as a \texttt{Shape} type. \\ \\
\textit{\textbf{Note:}} Like with classes, defining an interface
defines a new type of the same name.

\subsection{Objects}
An object is a distinct value, often created from a class blueprint:
each object has its own copy of fields and methods.

\subsection*{Corollary: Objects without Classes}
Not all OOP languages use classes (e.g. JavaScript). Classes enable us
to create a consistent, \textbf{immutable}, set of objects based on the class
specification which is useful for polymorphism in statically typed
languages. In a lot of statically typed languages, adding to classes
after the class has already been specified is not allowed. However,
dynamically typed languages allow the addition of classes after they
have been defined.

\subsection{Inheritance}
Inheritance is the technique of defining a new class based on an
existing class/interface. This allows us to not only reuse code, but
ensure that different classes behave in a standardized manner
(e.g. \texttt{sets, vectors, lists} can all be iterated via an
\texttt{iterator}). There are three main high-level concepts of inheritance:
\begin{enumerate}[label=(\roman*)]
\item Interface Inheritance: Creating many subclasses that share a
  common public interface.
\item Implementation Inheritance: Reusing a base class's method
  implementations. i.e. A derived class inherits method
  implementations from a base class.
\item Subclassing Inheritance: A base class provides a public
  interface \textit{\textbf{and}} implementations for its methods. A
  derived class inherits both the base class's interface and its implementations.
\end{enumerate}

\subsubsection{Interface Inheritance}
Interfaces define a public set of related methods. A derived
class\footnote{Unrelated classes can support the same interface, as
  long as they are able implement all of the methods.}\footnote{A
  given class may support multiple interfaces as long as it implements
  all of the methods of \textit{\textbf{both}} interfaces.} will then
inherit the interface and provide implementations for
\textit{\textbf{all}} of its methods. \\ 
Best practices include:
\begin{enumerate}[label=(\roman*)]
\item Use only in "can-support" relationships between a class and a
  group of behaviors (e.g. a \texttt{Car} can support washing).
\item Use when you have different classes that need to support related
  behaviors, but aren't related in any other way
  (e.g. a \texttt{Shape} interface supports calculations for
  \texttt{area}).
\end{enumerate}

Pros/Cons of Interface Inheritance include:
\begin{enumerate}
\item [\textbf{P}] You can write functions focused on an interface, and have it
  apply to many different classes.
\item [\textbf{P}] A single class can implement multiple interfaces and play
  different roles.
\item [\textbf{C}] Interface inheritance does \textbf{not} facilitate code reuse.
\end{enumerate}

\subsubsection{Subclassing Inheritance}
A base class will define methods and (may define) virtual/abstract
functions. Derived classes inherit both the existing method
implementations as well as the interface. The derived class may
override the base class's method(s). Additionally, derived classes may
expand on the interface/class behavior. \\
Best practices include:
\begin{enumerate}[label=(\roman*)]
\item Use only in a "is-a" relationship (e.g. a \texttt{Circle}
  \textit{\textbf{is a}} \texttt{Shape})
\item The subclass should share the entire public interface
  \textbf{and} maintain the semantics of the super class's method(s).
\item Factor out common implementations from subclasses into a superclass.
\end{enumerate}

\subsubsection*{Example}
Given the following \texttt{Collection} and \texttt{Set} classes:
\begin{verbatim}
class Collection {
public:
    void insert(int x) { ... }
    bool delete(int x) { ... }
    void removeDuplicates(int x) { ... }
    int  count(int x) const { ...}
...
private:
...
};

class Set : public Collection {
public:
    void insert(int x) { ... }
    bool delete(int x) { ... }
    bool contains(int x) const { ... }
...
private:
...
};
\end{verbatim}
is not an appropriate use of subclassing for two main reasons:
\begin{enumerate}[label=(\roman*)]
\item The derived class (\texttt{Set}) doesn't support the full
  interface of the base class (\texttt{removeDuplicates(), count()}
  are missing).
\item The derived class (\texttt{Set}) doesn't share the same
  semantics as the base class (\texttt{Set} doesn't allow for
  duplicates, while \texttt{Collection} does).
\end{enumerate}

\subsubsection*{Corollary: Delegation}
Delegation/composition is when a class embeds the original object and
uses forward calls to the original class. This technique is used when
you want to leverage another class's implementation but don't want to
support its interface. An example is provided below:

\subsubsection*{Example}
Consider an alternative \texttt{Set} implemenation
(\texttt{Collection} from (\textbf{5.5.2})):
\begin{verbatim}
class Set {
public:
    void insert(int x) {
        if (c_.count(x) == 0)
            c_.insert(x);
    }

    bool delete(int x) { return c_delete(x); }

    bool contains(int x) const { return c_count(x) == 1; }
...
private:
    Collection c_;
};
\end{verbatim}
Pros/Cons of sublcassing inheritance include:
\begin{enumerate}
\item [\textbf{P}] Eliminates code duplication/encourages code reuse.
\item [\textbf{P}] Simpler maintenance.
\item [\textbf{P}] If you understand the base class's interface, using
  subclasses should be trivial.
\item [\textbf{P}] Functionality on superclasses can also operate on
  subclasses without any changes to implementation.
\item [\textbf{C}] Often results in poor encapsulation.
\item [\textbf{C}] Changes to superclass can break subclasses (fragile
  base class).
\end{enumerate}

\subsubsection{Implemenation Inheritance}
A derived class inherits the method implementations of a base class
but \textbf{not} its public interface (e.g. \texttt{private
  Collection} instead of \texttt{public Collection} in
(\textbf{5.5.2})). Pure implementation inheritance is rarely used, but
is rather used in conjunction with composition and delegation.

\subsubsection*{Example}
Pure Implementation Inheritance:
\begin{verbatim}
class Set : private Collection {
public:
    void add(int x) {
        if count(x) == 0)
            insert(x);
    }

    bool erase(int x) { return delete(x); }

    bool contains(int x) const { return count(x) > 0; }
...
};
\end{verbatim}

\subsubsection*{Example (cont.)}
Composition with Delegation:
\begin{verbatim}
class Set {
public:
    void add(int x) {
        if c_.count(x) == 0)
            c_.insert(x);
    }

    bool erase(int x) { return c_.delete(x); }

    bool contains(int x) const { return c_.count(x) > 0; }
...
private:
    Collection c_;
};
\end{verbatim}
\textit{\textbf{Note:}} Implementation inheritance is usually only
used if you want your derived class to have access to protected
members of the base class. Composition doesn't allow the outer class
to access protected members of the contained class.

\subsubsection{Prototypal Inheritance}
In JavaScript, every object has an implicit reference to a parent (a
"prototype") object. By default, the parent is Javascript's empty
\texttt{Object}. However, it can be explicitly assigned to implement
inheritance.

\subsection{Corollary: Additional Inheritance Topics}
\subsubsection{Construction, Destruction, Finalization}
\begin{enumerate}[label=(\roman*)]
\item Construction: A derived class calls its superclass's
  constructor, initializing the base part(s) of the
  object\footnote{Constructors are called outside in (base $\to$
    derived) since it may be the case that we use the base class's
    code to initialize our derived class.}, and then
  initializes its own parts of the object.
\item Destruction: Destructors are called inside
  out\footnote{Destructors are called inside out
    (derived $\to$ base) since the converse is true: we can't access derived
    class attributes from a base class. So we need to clean up the
    derived class first before cleaning up its base class.} and are
  meant to destroy the object. 
\item Finalizers: Language-dependent.
\end{enumerate}

\subsubsection{Overriding}
There are three main topics related to overriding methods/classes:
\begin{enumerate}[label=(\roman*)]
\item How a base class controls which of its methods can be overridden
\item How a derived class ensures base methods are properly overridden
\item How an overriding method can access the base method
\end{enumerate}

\subsubsection*{Controlling Overriding}
Some languages explicitly state which methods/classes can/'t be
overridden. Regardless, a base class must determine which methods/classes
can/'t be overridden. Base methods can be invoked using the
\texttt{super} keyword or an equivalent (specify which scope the
function is defined in).

\subsubsection*{Corollary: Overriding vs Overloading}
Overriding is redefining a base class to alter behavior, whereas
overloading defines an entirely new function.

\subsubsection*{Corollary: Language-specific Override Semantics}
Java only lets the programmer call an immediate superclass because
otherwise, it would violate encapsulation and allow a subclass to
bypass its parent's behavior. The derived class should only know about
one level of inheritance. \\
In some languages, \texttt{final} or \texttt{override} aren't
enforced, but they are still useful since it alerts the reader that a
class/method has a certain property which \textbf{should} be maintained.

\subsubsection{Multiple Inheritance and its Issues}
Multiple inheritance is when a derived class implements two+
superclasses. It is often considered an anti-pattern and is not
recommended. A preferred approach (if multiple inheritance is
necessary) is to have the class implement multiple interfaces
instead. One such example of why multiple inheritance is not
recommended is the following (often referred to as the \textit{Diamond
  Pattern}):
\begin{verbatim}
class CollegePerson {
public:
    CollegePerson(int income) { income_ = income; }
    int income() const { return income_; }
...
private:
    int income_;
};

class Student: public CollegePerson {
public:
    Student(int part_time_income) : CollegePerson(part_time_income) { ... }
...
};

class Teacher: public CollegePerson {
public:
    Teacher(int salary) : CollegePerson(salary) { ... }
...
};

class TA: public Student, public Teacher {
public:
    TA(int part_time_income, int salary) : Student(part_time_income), Teacher(salary) { ... } 
...
};
...
int main() { TA amy(1000, 8000); ... }
\end{verbatim}
The following will set \texttt{income\_ = 1000} when
\texttt{Student(...)} is called, but will reset \texttt{income\_ =
  8000} when \texttt{Teacher(...)} is called since they both inherit
from \texttt{CollegePerson}.

\subsubsection{Abstract Methods/Classes}
Abstract methods are function prototypes without an implementation. An
abstract class is a class that contains one+ abstract methods. An
abstract method \textbf{forces} a derived class to redefine and
implement the abstract method. \\
\textit{\textbf{Note:}} Just like concrete classes, a new abstract
class will implicitly create a new type with the same name. \\
Best practices include:
\begin{enumerate}[label=(\roman*)]
\item Use an abstract method when a default behavior doesn't make
  sense (e.g. \texttt{area} doesn't have a generic formula).
\item Abstract classes over interfaces when all subclasses share a
  common implementation for one+ methods/fields (e.g. A \texttt{Human}
  and \texttt{Dog} can both \texttt{walk()}).
\end{enumerate}
\textit{\textbf{Note:}} A private method can usually be declared abstract but
it's pretty useless since no subclass can implement it, so don't do
it.

\subsubsection{Inheritance and Typing}
Recall the concept of sub/super typing. (e.g. \texttt{float} is a
subtype of \texttt{double}). Inheritance implicitly defines sub/super
types (e.g. \texttt{Student} is a subtype of \texttt{Person}).

\subsubsection*{Corollary: Value/Reference Types}
\textit{\textbf{Value Types}} are associated with a concrete class and
are used to define referenes, object references, pointers, and
instantiate objects\footnote{Reference Types \textbf{cannot}
  instantiate objects since there are no concrete implementations for one+
  function(s).}. \\
\textit{\textbf{Reference Types}} are associated with an interface or
an abstract class and are used to define references, object
references, adn pointers.

\subsubsection*{Corollary: Difference between a Class and a Type}
Consider two classes: \texttt{Person} and \texttt{Student}, where
\texttt{Student} is a subclass of \texttt{Person}. Then, we have the
following relationships: \\
\[
  \begin{xy}
    (0,15)*+{\text{Person \textbf{Class}}}="a"; 
    (65, 15)*+{\text{Person \textbf{Type}}}="b";
    (0, 0)*+{\text{Student \textbf{Class}}}="c";
    (65, 0)*+{\text{Student \textbf{Type}}}="d";
    {\ar         "a";"b"}?*!/_5pt/{\textit{implicitly defines}};
    {\ar         "c";"a"}?*!/_27pt/{\textit{subclass of}};
    {\ar         "d";"b"}?*!/^25pt/{\textit{subtype of}};
    {\ar         "c";"d"}?*!/^5pt/{\textit{implicitly defines}};
  \end{xy}
\]
Similarly, for inheritance subtyping, we have: \\
\[
  \begin{xy}
    (0,15)*+{\text{Washable \textbf{Interface}}}="a"; 
    (65, 15)*+{\text{Washable \textbf{Type}}}="b";
    (0, 0)*+{\text{Car \textbf{Class}}}="c";
    (65, 0)*+{\text{Car \textbf{Type}}}="d";
    {\ar         "a";"b"}?*!/_5pt/{\textit{implicitly defines}};
    {\ar         "c";"a"}?*!/_27pt/{\textit{implements}};
    {\ar         "d";"b"}?*!/^25pt/{\textit{subtype of}};
    {\ar         "c";"d"}?*!/^5pt/{\textit{implicitly defines}};
  \end{xy}
\]

\subsection{OOP Design Best Practices}
\begin{itemize}[align=right]
\item [\textbf{S}]ingle Responsibility Principle: Each class should
  have a single, limited responsibility - if it has more, it should be
  split into two+ classes.
\item [\textbf{O}]pen/Closed Principle: Design classes to minimize
  coupling (new classes should work with existing classes without modification).
\item [\textbf{L}]iskov's Substitution Principle: A properly written
  subclass should be substitutable for its superclass and the code
  should still work.
\item [\textbf{I}]nterface Segregation Principle: No class should be
  forced to depend on an interface that contains methods it does not use.
\item [\textbf{D}]ependency Inversion Principle: If class \texttt{A}
  uses class \texttt{B}, design \texttt{A} to operate on an interface \texttt{I}
  and have \texttt{B} implement \texttt{I}. Don't have \texttt{A}
  directly use \texttt{B}.
\end{itemize}




\section{Control Flow}

\subsection{Expression Evaluation}
Languages like C++ do not have an associativity/expression evaluation
order specified in the language spec. This makes expression
(potentiallly) ambiguous and can be different between
implementations.

\subsection{Associativity}
Most languages are left-associative when evaluating mathematical
expressions (with few exceptions (e.g. sponentiation, assignment,
unary). (e.g. \texttt{c - d + f()} $\iff$ \texttt{(c - d) + f()})

\subsection{Short Circuiting}
Short circuiting is when a (most often boolean) condition is
satisfied/invalidated before all of the sub-expressions are
evaluated.

\subsubsection*{Example ($| \ |$)}
\begin{verbatim}
if(a() || b() || c()) { do_something(); }
<==>
if(a()) { do_something(); }
else if(b()) { do_something(); }
else if(c()) { do_something(); }
\end{verbatim}

\subsubsection*{Example (\&\&)}
\begin{verbatim}
if(a() && b() && c()) { do_something(); }
<==>
if(a()) 
    if(b()) 
         if(c()) { do_something(); }
\end{verbatim}
\textit{\textbf{Note:}} Not all languages implement short circuiting.





\section{Iteration}
Loops are either:
\begin{enumerate}[label=(\roman*)]
\item Counter-controlled (e.g. \texttt{for (int i = 0; i < n; i++)}
\item Condition-controlled (e.g. \texttt{while (condition)})
\item Collection-controlled (e.g. \texttt{for (elem : const auto\& elements)})
\end{enumerate}
Collection and (most often) counter-controlled rely on iterators.


\subsection{Iterable Objects}
An iterable object is one that can be iterated over via an iterator:
\begin{enumerate}[label=(\roman*)]
\item Containers (e.g. array, list, tuple, vector, dictionary, etc)
\item I/O (e.g. disk file/network stream)
\item Generators (e.g. sequences)
\end{enumerate}


\subsection{Iterators}
An iterator is an object that enumerates through an iterable object,
creating an interface for enumerating through (potentially complex)
data structures (e.g. hashmap). Examples are as follows:
\begin{enumerate}[label=(\roman*)]
\item Enmerate a container
\item Enumerate external sources
\item Enumerate through an abstract sequence\footnote{Abstract
    sequences: Given an arbitrary sequence $(x_n)$, a generator will
    only store $x_i$ via an iterator.}
\end{enumerate}
An iterable object returns a new instance of an iterator every time
one is requested. Iterators have some way of calling a \texttt{next}
method to retrieve the next element from the enumerated iterable.

\subsection*{Corollary: Composition of Iterators/Iterable Objects}
Iterators and Iterables are two distinct objects. The iterator will
enumerate \textit{through} an iterable object. The reason for this
is because we don't want the iterator to be coupled with the
iterable. This allows for multiple instances of an iterator for the
same iterable.

\subsection{Implementation}
\subsubsection{Traditional Classes}
An iterator object is implemented via a regular class, and the
iterable returns an instance of the class. An iterator must implement
(at minimum) the \texttt{next} function. An example is as follows: 
\begin{verbatim}
class Iterator:
  def __init__(self, arr):
    self.arr = arr
    self.index = 0

  def __next__():
    if self.index < len(self.arr):
      val = self.arr[self.index]
      return val
    else:
      raise StopIteration
\end{verbatim}
and is used in tandem as such:
\begin{verbatim}
class StrList:
  def __init__(self):
    self.arr = []
...
  def __iter__(self):
    it = Iterator(self.arr)
    return it
\end{verbatim}
This initializes a new instance of \texttt{Iterator} and returns it to
the caller. This enables us to have multiple \textbf{independent}
iterators pointing to the same iterable. \\ \\
Iterators are used to implement different type of iterable loops, and
implementations of those can be found on HW9 because I'm lazy and
don't want to type it out here.

\subsection{Generators}
A generator ("true iterator") stores a finite amount of data rather
than the entire iterable itself. This allows for infinite lists in
many languages: Since generators only store $x_i \in (x_n)$, this is
much more storage efficient for sufficiently large lists. An example
of a generator that will iterate over $(x_n) := \{x : x \% 2 = 0\}$:
\begin{verbatim}
def n_evens(n):
i = 0
while i < n:
  yield i
  i += 2
\end{verbatim}

\subsection{First-Class Functions (For-Each)}
A for-each loop is a type of iterator-based loop that functions
similar to a map (basically the same thing). They are built into
iterable objects and are \textit{usually} defined as follows:
\begin{verbatim}
class StrList:
  def __init__(self):
    self.arr = []
...
  def forEach(self, f):
    for x in self.arr:
      f(x)
\end{verbatim}
Note that \texttt{for x in self.arr} is implemented via an iterator
(see HW9). This function takes in a lambda \texttt{f} and applies it
to each element inside \texttt{self.arr}.





\section{Concurrency}
Concurrency is a form of parallelism: Independent (immutable)
functions/tasks can be run in parallel to improve efficiency.

\subsection{Multithreading}
A task is split up into multiple \textit{threads} of
execution that run simultaneously via a fork-join pattern:
\begin{enumerate}[label=(\roman*)]
\item Split a task into disjoint partitions
\item Process all partitions in parallel
\item Join partitions before resuming serial execution
\end{enumerate}

\subsection*{Corollary: Race Conditions}
Suppose you are given two functions that read/write on the same piece of
memory/data. Then, running the following
\begin{verbatim}
int shared_data;
void someA() { *writes to shared_data* }
void someB() { *deletes from shared_data* }
...
int main() {
  std::thread a ( someA() );
  std::thread b ( someB() );

  a.join();
  b.join();

  return 0;
}
\end{verbatim}
is undefined behavior, since \texttt{shared\_data} can potentially be
interuppted by either thread at any time. This is known as a race
condition. To prevent this, thread-safe functions are usually pure.

\subsection{Event-Driven}
A callback function is called when an \textit{event} (e.g. button click) occurs
and handles the completed event. These functions are then run via an
event-loop:

\begin{verbatim}
def event_loop(self):
  while True:
    self.handle_events()
    self.next_statement()
...

def event_loop(self):
  for obj in page_tree:
    if obj.event_occured():
      f = obj.handler()
      self.run_queue.append(f)
...

def next_statement():
  if len(self.run_queue) > 0:
    f = self.dequeue()
    f()
\end{verbatim}

\subsection*{Corollary: Hanging}
Since event-loops are some form of \texttt{while (true)} loops, if a
function in the run queue is CPU bound, the event may hang (and may
never terminate).

\subsection*{Corollary: Chaining Operations (Promises \& async/await)}
Promises: We call a function that will start running a statement
asynchronously. When the statement returns, something analogous to a
\texttt{then()} and \texttt{catch()} will handle the
fulfillment/error-handling of a Promise. An example is as follows:
\begin{verbatim}
const promise = new Promise((resolve, reject) => {
  // Some asynchronous operation
  // If the operation is successful, call resolve(value)
  // If the operation fails, call reject(error)
});
...
promise
  .then((value) => { *Handle the fulfilled value* })
  .catch((error) => { *Handle the error* });
\end{verbatim}
\texttt{async/await} is analogous to Promises and syntax is as
follows:
\begin{verbatim}
async function myAsyncFunction() {
  try {
    const result = await promise; // Wait for the Promise to fulfill
    // Do something with the result
  } catch (error) { *Handle any errors* }
}
\end{verbatim}
\textit{\textbf{Note:}} Async functions are built upon the ideas of
generators and are called coroutines\footnote{Coroutines are important
  to CS but I guess aren't covered too extensively lol.}.




\section{Logic Programming (Prolog)}
Logic programming is a language paradigm that relies on a knowledge
base (set of facts) and a set of rules on which to operate on to come
to a conclusion on a set of queries. Prolog in particular uses a
closed-world assumption\footnote{Closed-world Assumption: Anything
  that is not explicitly stated to be true is false.}.

\subsection{Definitions}
\begin{enumerate}[label=(\roman*)]
\item Knowledge base: A set of facts about the world.
\item Atom: A variable.
\item Attribute: Indicates whether an atom is true or false
  (e.g. \texttt{atom} \textit{is} \texttt{attribute}).
\item Relationship: A relationship between two ore more atoms
  (e.g. \texttt{atom$_1$} \textit{is} \texttt{attribute} \textit{of} \texttt{atom$_2$}).
\item Fact: A predicate expression that declares either an attribute
  or relationship.
\item Rule: An expression that defines a new fact in relation to
  existing facts/rules (e.g. \texttt{*head* \{rule(...)\} :- *body*}).
\end{enumerate}

\subsection{Propositional Logic Conversions}
The following are how we write propositional logic in Prolog:
\begin{enumerate}[label=(\roman*)]
\item If : $A \implies B \iff$ \texttt{A :- B}
\item And: $A \land B \iff$ \texttt{A, B}
\item Or: $A \lor B \iff$ \texttt{A; B}
\item Not: $\lnot A \iff$ \texttt{not(A)}
\end{enumerate}

\subsection*{Examples}
Facts:
\begin{verbatim}
outgoing(ren).       ren is outgoing.
silly(ren).          ren is silly.
parent(alice, bob).  alice is parent of bob.
age(ren, 80).        ren is age of 80.
parent(bob, carol).  bob is parent of carol.
\end{verbatim}
Rules:
\begin{verbatim}
comedian(P) :- silly(P), outgoing(P).             P is comedian if:
                                                  P is silly and P is outgoing. //
grandparent(X, Y) :- parent(X, Q), parent(Q, Y).  X is grandparent of Y if:
                                                  X is parent of Q and Q is parent of Y. //
old_comedian(C) :- comedian(C), age(C, A) > 60.   C is old_comedian if:
                                                  (C is age of A) is greater than 60. //
ancestor(X, Z) :- parent(X, Z)                    X is ancestor of Z if:
                                                  X is parent of Z. //
ancestor(X, Z) :- parent(X, Z), ancestor(Y, Z).   X is ancestor of Z if:
                                                  X is parent of Z and Y is ancestor of Z. //
serious(X) :- not(silly(X)).                      X is serious if:
                                                  X is (not silly). //
\end{verbatim}
Queries:
\begin{verbatim}
?- silly(ren)        --> true
?- parent(alice, X)  --> X = bob
?- parent(X, Y)      --> X = alice, Y = bob
                         X = bob, Y = carol
\end{verbatim}

\subsection{Resolution}
Resolution is the process of resolving a query against \textbf{all}
facts/rules and obtaining either a boolean or one (or more) mappings.

\subsection*{Example}
\begin{verbatim}
parent(nel, ted).
parent(ann, bob).
parent(ann, bri).
parent(bri, cas).

gparent(X, Y) :- parent(X, Q), parent(Q, Y).
...
?- gparent(ann, Y)
\end{verbatim}
The following will resolve (as a tree) to:
\begin{flalign*}
  \texttt{gparent(X = ann, Y) :- }
  &\texttt{parent(ann, Q),} && (*) \\
  &\texttt{parent(Q, Y).} && (**) \\ \\
%
  (*) \implies &\texttt{Q = bob,} && (1) \\
  &\texttt{Q = bri} && (2) \\ \\
%  
  (1) \implies &\texttt{parent(X = ann, Q = bob),} \\
  &\texttt{parent(Q = bob, Y).} \\
  (**) \implies &\texttt{Y = } \O \\ \\
%  
  (2) \implies &\texttt{parent(X = ann, Q = bri),} \\
  &\texttt{parent(Q = bri, Y).} \\
  (**) \implies &\texttt{Y = cas} \\
  \implies &\texttt{\{X = ann, Q = bri, Y = cas\}}
\end{flalign*}
returns \texttt{\{X = ann, Q = bri, Y = cas\}}


\subsection{Unification}
Resolution is the process of resolving a query against \textbf{one}
facts/rules and obtaining either a boolean or one (or more)
mappings. Unmapped variables will map (only once) to the first atom it
matches with.

\subsubsection*{Example: Matching}
Assuming an initial mapping of \texttt{\{ \}}:
\begin{align*}
  \texttt{teach(carey, cs131)} &\textit{ matches } \texttt{teach(carey,
  cs131)} \\
  \texttt{teach(X, cs131)} &\textit{ matches } \texttt{teach(carey,
  cs131)} \\
  \texttt{teach(X, cs131)} &\textit{ no match } \texttt{teach(carey,
  nomatch)}
\end{align*}
Assuming an initial mapping of \texttt{\{ X = cs131 \}}:
\begin{align*}
  \texttt{teach(carey, X)} &\textit{ matches } \texttt{teach(carey,
  cs131)} \\
  \texttt{teach(carey, X)} &\textit{ no match } \texttt{teach(carey,
  nomatch)}
\end{align*}

\subsubsection*{Extracted Mapping}
Assuming an initial mapping of \texttt{\{ \}} and \texttt{\{ X = carey
  \}}:
\begin{align*}
  \texttt{teach(X, cs131)} &\textit{ and } \texttt{teach(carey,
                             cs131)} \\
  \texttt{teach(X, cs131)} &\textit{ and } \texttt{teach(carey,
                             cs131)}
\end{align*}
returns \texttt{\{ X = carey \}} and \texttt{\{ \}} respectively. \\ \\
Assuming an initial mapping of \texttt{\{  \}} and \texttt{\{ X = carey \}}:
\begin{align*}
  \texttt{teach(X, cs131)} &\textit{ and } \texttt{teach(Y,
                             cs131)} \\
  \texttt{teach(X, cs131)} &\textit{ and } \texttt{teach(X,
                             cs131)}
\end{align*}
returns \texttt{\{ X = Y \}} and \texttt{\{ Y = X \}} $\implies$
\texttt{\{ Y = carey \}} respectively. \\ \\

\subsection{Matching Criterion}
To match a goal tree with a node in the fact/rule tree, we need:
\begin{enumerate}[label=(\roman*)]
\item functor (name) match
\item arity (\# of parameters) match
\item defined atoms/variables match (unmapped variables match with
  anything, including other unmapped variables)\footnote{Prolog
    unifies from left to right, mapping each variable exactly once.} 
\end{enumerate}

\subsection{Lists}
\textbf{Preface:} \texttt{fact(X, X).} is a new type of fact that has variables
instead of atoms. Then, we get:
\begin{verbatim}
is_the_same(one, one)  --> true
is_the_same(one, two)  --> false
\end{verbatim}
\subsubsection{List Processing (Examples)}
\subsubsection*{First Element}
Consider the following: \texttt{is\_head\_item(X, [X | XS]).} Then, we
query:
\[\texttt{?- is\_head\_item(one, [one, two, three])} \implies
  \texttt{\{ X = one \}} \implies \texttt{true}.\]

\subsubsection*{Is Member}
Consider the following:
\begin{verbatim}
is_member(X, [X | Tail]).
is_member(Y, [Head | Tail]) :- is_member(Y, Tail).
\end{verbatim}
Then, we query:
\[\texttt{?- is\_member(one, [two, one, three])} \implies
  \texttt{true}.\]

\subsubsection*{Other Functions}
\begin{verbatim}
append(X, Y, Z)    X := Y + Z
sort(X, Y)         Y := sorted X
permutation(X, Y)  Y := X can be reordered to = Y
reverse(X, Y)      X := reverse of Y
member(X, Y)       X is in Y
sum_list(X, Y)     Y = summation of X
\end{verbatim}
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End: