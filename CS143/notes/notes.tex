\documentclass{report}
\usepackage{amsmath, amsthm, amssymb, graphicx, enumitem, esvect}
\usepackage[english]{babel}
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
\usepackage[most]{tcolorbox}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{nicefrac}

\newenvironment{definition}[1]{\begin{tcolorbox}[title={Definition: #1}]}{\end{tcolorbox}}
\newenvironment{aside}[1]{\begin{tcolorbox}[title={Aside: #1},colback=blue!5!white,colframe=black!75!blue]}{\end{tcolorbox}}


% \newcommand{\refto}[2]{\textbf{\ref{#1:#2} \nameref{#1:#2}}}
\renewcommand{\bf}[1]{\textbf{{#1}}}
\renewcommand{\tt}[1]{\texttt{{#1}}}
\renewcommand{\it}[1]{\textit{{#1}}}
\newcommand{\ib}[1]{\textit{\textbf{{#1}}}}
\newcommand{\R}{\mathbb{R}}

\title{CS 143}
\author{Warren Kim}
\date{}

\begin{document}
\maketitle

\tableofcontents
\newpage

\section{Purpose of a Database}
We will be studying (mostly) Relational DataBase Management Systems (RDBMS).
\begin{definition}{Database}
    A \bf{database} abstracts how data is stored, maintained, and processed. It is a system that uses
    advanced data structures to store and index data.
\end{definition}
A database abstracts away the data integrity and file management aspect of CRUD operations. Moreover,
a database provides us with a single location for all of the data, even if the database itself is
distributed.





\section{Abstraction Layers}
There are three layers of abstraction: physical, logical, and view. 
\begin{definition}{Physical Abstraction}
    The \bf{physical abstraction} defines the data and its relationships to other data within the 
    database.
\end{definition}
\begin{definition}{Logical Abstraction}
    The \bf{logical abstraction} deals with how we interface with the database.
\end{definition}
\begin{definition}{View Abstraction}
    The \bf{view abstraction} refers to specific use cases and filters the data from the logical
    abstraction.
\end{definition}
We start by learning the logical abstraction.





\section{Instances and Schema}
\begin{definition}{Schema and Instance}
    A \bf{schema}\footnote{Note: schema can also refer to a relation (table).} is the overall design 
    of a database. It defines the structure of the data as well as how it is organized. \vspace{10pt}

    An \bf{instance} of a database is the actual set of data stored in the database at a particular 
    moment in time. 
\end{definition}





\section{Data Models}
Data models define how we design databases and interact with data. We want to answer the following:
\begin{enumerate}[label=\it{(\roman*)}]
    \item How do we define data?
    \item How do we encode relationships among data?
    \item How do we impose constraints on data?
\end{enumerate}
Data models are either an Implementation model or a Design mechanism. Implementation models build 
databases from the ground up while design mechanisms are implemented as features in a database. We 
discuss five major types (an several niche ones).

\subsection{Relational}
In a relational model, all data is stored as a \ib{relation}\footnote{Note: tables are an 
implementation of relations.}. Rows represent individual $n$-tuple units (\ib{records}). Columns 
represent (typed) \ib{attributes} common to all records in the relations.

\subsection{Entity-Relationship (ER)}
An entity-relationship model uses a collection of basic objects (\ib{entities}) and define 
\ib{relationships} among them.

\subsection{Object-Oriented}
The object-oriented model is similar to OOP with encapsulation, methods, adn object identity. It
was originally an implementation model but is now a design mechanism.

\subsection{Document (Semi-Structured)}
A document model stores records as \ib{documents}, which do \ib{not} have an enforced schema. This 
allows for more versatility in the type of data stored in the database.

\subsection{Network/Hierarchical/Graphical}
A graph model is analogous to how we think. Records are stored as \ib{nodes} and relationships 
between records as \ib{edges}.

\subsection{Vector}
A vector model stores records as \ib{vectors} in $\mathbb{R}^{n}$, and are stored in a way that 
enables efficient retrieval and comparison (e.g. nearest neighbor[s]).

\subsection{Key-Value}
A key-value model stores data as a key-value pair (typically using a hash function). In this model,
data typically lives in RAM as opposed to disk.

\section{Database Languages}
There are two main semantic systems when working with databases:
\begin{enumerate}[label=\it{(\roman*)}]
    \item Data Manipulation Language (DML)
    \item Data Definition Language (DDL)
\end{enumerate}
Note that a relational model typically uses SQL for both DDL and DML.

\subsection{Data Manipulation Language}
DML's can either be procedural or declarative.
\begin{definition}{Query}
    A \ib{query} is a written expression to retrieve or manipulate data.
\end{definition}
\begin{aside}{A Note on SQL}
    SQL is a declarative language, and as such, it is hard to perform sequential or 
    nontrivial\footnote{Nontrivial: Any computation where we have to specify \it{how} to perform
    the computation.} computations in SQL. To remedy this, a common option is to write an \ib{ETL job}
    in another language (pick one). We \bf{E}xtract the data from the database (using a connection
    driver), \bf{T}ransform the data using another lanuage (pick one!), and \bf{L}oad the data
    into a new table using the same driver. We can schedule these jobs using something like \tt{cron}.
\end{aside}

\subsection{Data Definition Language}
DDL's specify a schema: a collection of attribute names and data types, consistency constraints, and
optionally storage structure and access methods. There are four types of consistency constraints:
\begin{enumerate}[label=\it{(\roman*)}]
    \item Domain constraints define the domain of an attribute (e.g. \tt{tinyint}, \tt{enum}, etc.).
    \item Assertions are business rules that must hold true (e.g. an enforced prerequisite for a 
        class must be present in your transcript before you can add a class to your study list).
    \item Authorization determines who can do what (e.g. full CRUD, read-only, etc.).
    \item Referential integrity ensures that links from one table to another must be defined (Suppose
        we have two relations $R, R'$. If there is a link $f : R \to R'$, then $f$ is surjective).
\end{enumerate}

\section{Data Storage and Querying}
\begin{definition}{Storage Manager}
    A \ib{storage manager} that abstracts away how the data is laid out on disk.
\end{definition}
A storage manager is helpful because reading data from disk to RAM is \it{slow}, and the storage
manager handles swapping\footnote{Swapping: Virtual memory in CS111!} and makes retrieval efficient.

\begin{definition}{Query Manager}
    A \ib{query manager} takes the DML statements and organize them into a 
    \it{query plan}\footnote{Note: The query plan dictates the performance of a query.} that 
    ``compiles'' a query (using relational algebra) and executes the instruction(s).
\end{definition}

\section{Keys}
\begin{aside}{A Note on Context and Instance}
    Based on \bf{context} means that the given data is a subset of the complete dataset.
    \newline
    Based on \bf{instance} means that we treat the given data as the complete dataset.
\end{aside}

\subsection{Superkey}
\begin{definition}{Superkey}
    A \bf{superkey} is a set of one or more attributes that uniquely identifies a record (tuple) and 
    distinguishes it from all other records in the relation.\vspace{10pt}

    Formally, let $R$ be a relation with a set $S = \{a_1, a_2, \ldots, a_n : a 
    \text{ is an attribute of } R\}$. A \bf{superkey} is a subset $s \subseteq S$ such that $s$ 
    uniquely identifies each $n$-tuple in $R$.
\end{definition}
The superkey $s = S = \{a_1, a_2, \ldots, a_n\} = \bigcup^{n}_{i = 1} \{a_i\}$ is called the 
\ib{trivial superkey}. Additionally, $\emptyset$ is not a superkey. Further note that for every 
relation $R$, there exists at most $2^n - 1$ superkeys where $n$ is the number of 
attributes.


\subsection{Candidate Key}
\begin{definition}{Candidate Key}
    A \bf{candidate key} is a superkey such that no subset of the candidate key is a superkey; i.e.
    it is the minimal superkey. \vspace{10pt}

    Formally, let $R$ be a relation with a set $S = \{a_1, a_2, \ldots, a_n : a 
    \text{ is an attribute of } R\}$. A \bf{candidate key} is a superkey $s \subseteq S$ such that
    for every propery subset $t \subsetneq s$, $t$ is not a superkey.
\end{definition}
Candidate keys may vary in length, and the attributes of a candiate key may be \tt{NULL} as long as
it uniquely identifies an $n$-tuple in the relation.


\subsection{Primary Key}
\begin{definition}{Primary Key and Composite Key}
    A \bf{primary key} is a candidate key (chosen by the database designer) to enforce uniqueness
    for a particular use case.
\end{definition}
The primary key is typically chosen to be the minimal candidate key for simplicity. The attributes
of a primary key may not be \tt{NULL}. 

\subsection{Foreign Key}
\begin{definition}{Foreign Key}
    A \bf{foreign key} is a set of attributes that links tuples of two relations.\vspace{10pt}

    Formally, let $R, R'$ be relations with sets $S = \{a_1, a_2, \ldots, a_n : a 
        \text{ is an attribute of } R\}, S' = \{a'_1, a'_2, \ldots, a'_n : a' \text{ is an attribute of }
    R'\}$. A \bf{foreign key} is a key $s \subseteq S$ of $R$ that maps to the primary key 
    $p \subseteq S'$ of $R'$.
\end{definition}
Foreign keys are used to enforce referential integrity constraints; i.e. foreign keys in a 
relation $R$ are used to protect data in $R$ from being orphaned and/or inconsistent. Given two
relations $R, R'$ related via a foreign key, $R'$ is said to be the \it{referring} relation and 
$R$ the \it{referred} relation.

Let two relations $R, S$ be related via a foreign key, where $S$ is the \it{referring} relation
and $R$ is the \it{referred} relation. Suppose we want to remove an $n$-tuple $r \in R$. Then there
are two cases:
\begin{enumerate}[label=\textit{Case \arabic*}]
    \item If there is no $s \in S$ such that $s \mapsto r$, we simply remove $r$.
    \item If there is at least one $s \in S$ such that $s \mapsto r$, we can either throw an error
        to prevent the deletion of $r$ or \it{cascade}\footnote{Cascade: Delete $r$ and all 
        $s \in S$ that refer to $r$.} the delete.
\end{enumerate}





\section{Defining a Schema}
A schema can be written as \tt{relation(\underline{attribute$_{\tt{1}}$}, \tt{$\ldots$}, 
attribute$_{\tt{n}}$}) where underlined attributes represent the primary key.





\section{Relational Algebra}
describe relational algebra

\subsection{Selection}
\begin{definition}{Selection}
    \bf{Selection} retrieves a subset of tuples from a \it{single} relation $R$ that satisfies some
    predicate $\psi$ and returns a new relation $R' \subseteq R$, and is defined by
    \[\sigma_{\psi}(R) = R' = \{ t \in R : \psi(t) \}\]
    where $\psi$ is a boolean predicate on attributes and values with respect to a unary or binary 
    operator\footnote{We may use the following operators: $\{=, \neq, <, >, \leq, \geq, \lnot \}$.}
\end{definition}
We can build complex predicates using conjunction $\land$ (and) or disjunction $\lor$ (or). 
\begin{center}\bf{Note: that selection $\sigma$ is implemented as \tt{WHERE} in SQL.} \end{center}
Below are a list of examples of selection, assuming all attributes and relations are well-defined:
\begin{enumerate}[label=\textit{(\roman*)}]
    \item $\sigma_{(\tt{dislikes} < \tt{likes})}(\tt{youtube\_video})$
    \item $\sigma_{(\tt{cat\_id} = 17)}(\tt{youtube\_video})$
    \item $\sigma_{([\tt{dislikes} < \tt{likes}] \land [\tt{views} > 1000000] \land [\tt{cat\_id=24}])}(\tt{youtube\_video})$
    \item $\sigma_{(\tt{dislikes} < \tt{likes})}(\sigma_{(\tt{views} > 1000000)}(\sigma_{(\tt{cat\_id} = 24)}(\tt{youtube\_videos})))$
\end{enumerate}
Note that \it{(iii)} and \it{(iv)} are equivalent.

\subsection{Projection}
\begin{definition}{Projection}
    \bf{Projection} extracts attributes from a set of tuples and removes duplicates. Given a 
    relation $R$, $n$-tuple $t$, and a set of attributes $a_1, \cdots, a_n$,
    \[\Pi_{a_1, \cdots, a_n}(R) = \{ t[a_1, \cdots, a_n] : t \in R \}\]
    Projection is usually the last (outermost) operation done on a relation.
\end{definition}
\begin{aside}{Projection?}
    We call it a projection because we are collapsing an $n$-tuple down to an $(n - k)$-tuple. That
    is, we take the $n$-tuples in a relation $R_n$ and collapse them into a set of $(n-k)$-tuples 
    in a new relation $R'_{n - k}$. \footnotetext{Here, $R_n$ is a relation with $n$ attributes.}
\end{aside}


% Consider the following relation $R$:
% \begin{center}
%     \begin{tabular}{c|c|c}
%         A & B & C \\
%         \hline
%         $\alpha$ & $\delta$ & $\xi$ \\
%         $\beta$ & $\delta$ & $\psi$ \\
%         $\gamma$ & $\eta$ & $\xi$
%     \end{tabular}
% \end{center}









\end{document}
